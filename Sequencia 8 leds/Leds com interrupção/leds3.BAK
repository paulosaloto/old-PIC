                                    // PROGRAMA - SEQUÊNCIA DE LEDS USANDO INTERRUPÇÃO EXTERNA (RB0) - 16/02/2012

#include <16F877a.h>                //Inclui a biblioteca do pic 16F877A
#fuses XT,NOWDT,NOPROTECT,PUT       //Define para o compilador: a faixa de frequência do clock (pode ser LS, XT, HS),
                                    //não uso do watchdog timer,
                                    //não uso de proteção de código,
                                    //uso do Power-up-timer, temporizador utilizado para inicialização do PIC.

#use delay(clock=4000000)           //Define a frequência de clock.

#use fast_io(a)                     //Estas diretivas definem que o controle E/S das portas será definido pelo programador
#use fast_io(b)
#use fast_io(c)
#use fast_io(d)
#use fast_io(e)

#byte porta = 5                     // Definição de ponteiros para as portas
#byte portb = 6
#byte portc = 7
#byte portd = 8
#byte porte = 9

int dir=0;                          //insere a variável direcional que determina para que lado os bits serão rotacionados,
                                    //que começa com valor=0 para que seja necessário pressionar o botão para a sequencia inicializar.
#int_EXT                            //diretiva para a interrupção;
void EXT_isr(void)                  //início da função de interrupção, que basicamente realiza o bounce da botoeira
{                                   //e inverte o sentido de rotação.
   do {                             //o programa não faz nada enquanto o botão continuar pressionado.
      delay_ms(150);
   }while (!bit_test(portb,0));
   if (dir==0) dir=1;
   else dir=0;
}

main()                              //função principal:
{
   int work;                        //definição da variável auxiliar;
   enable_interrupts(global);       //habilita todas interrupções;
   enable_interrupts(int_ext);      //habilita as interrupções externas;
   ext_int_edge (H_TO_L);           //define como início da interrupção quando RB0 sai de nível lógico alto para baixo;
   set_tris_a(0x00);                //define que todas as vias da portA do PIC serão saídas;
   set_tris_d(0x00);                //define que todas as vias da portD do PIC serão saídas;
   set_tris_b(0x01);                //define RB0 como entrada;
   port_b_pullups(TRUE);            //habilita os pull-ups;
   portb = (0x00);                  //zera o portb;
   portd = (0xFF);                  //define todos os leds acesos inicialmente;
   work = (0xFF);                   //define o mesmo valor de portd para work;
   while (1)                        //início do looping principal;
   {
      if(dir!=0 && portd>0x00)      //para a dir=1 (sentido direito):
      {                             //se portd for maior que zero, ele roda os bits para a direita;
         rotate_right(&work,2);     //se for menor que zero, significa que já chegou ao final, não precisa executar;
         bit_clear (work,7);        //a rotação. depois de rotacionar, limpa o bit mais significativo, caso haja
      }                             //algum ruído vindo do carry.

      if(dir==0 && work<0xFF)       //para dir==0, repete o mesmo procedimento anterior, só que vai rotacionando os bits
      {                             //para a esquerda e os acendendo;
         rotate_left(&work,2);
         bit_set (work,0);
      }
      portd=work;                   //aplica o valor rotacionado em portd;
      delay_ms(200);                //dá o tempo necessário para perceber o 'movimento' das luzes.

   }
}


